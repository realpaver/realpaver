###############################################################################
## This file is part of Realpaver, an interval constraint and NLP solver.    ##
##                                                                           ##
## Copyright (c) 2017-2022 LS2N, Nantes                                      ##
##                                                                           ##
## Realpaver is a software distributed WITHOUT ANY WARRANTY; read the file   ##
## COPYING for information.                                                  ##
###############################################################################

# The name of a parameter respects the pattern [A-Z](A-Z0-9_)*

###############################################################################
## GENERAL PARAMETERS                                                        ##
###############################################################################

# Time limit in seconds
TIME_LIMIT = 100.0

# Tolerance on the width of an interval domain of a constrained variable
# The value is a posiive real number followed by a character: A for an absolute
# or R for a relative tolerance.
XTOL = 1.0e-6A

# Tolerance on the distance between consecutive intervals in iterative methods
# The value is a posiive real number followed by a character: A for an absolute
# or R for a relative tolerance.
DTOL = 1.0e-6R

# Tolerance on the width of the enclosure of a global optimum
# The value is a posiive real number followed by a character: A for an absolute
# or R for a relative tolerance.
OBJ_TOL = 1.0e-6R

# Number of digits used to print floating-point numbers and intervals
FLOAT_PRECISION = 8

# Log level
# NONE:  no log
# MAIN:  main level e.g. display results of first-class algorithms
# INTER: intermediary level e.g. display nodes in a search algorithm
# LOW:   low level e.g. display quantities in iterative methods
# FULL:  verbose mode
LOG_LEVEL = FULL

# Trace displayed in a terminal (YES or NO)
TRACE = YES

###############################################################################
## BRANCH-AND-CONTRACT ALGORITHMS                                            ##
###############################################################################

# Limit on the number of nodes generated by search algorithms
NODE_LIMIT = 50000

# Limit on the depth of nodes of search trees
DEPTH_LIMIT = 50

# Limit on the number of solutions
SOLUTION_LIMIT = 13

# In a branch-and-bound algorithm, the next node can be either the node with
# the lowest lower bound or the node with the lowest upper bound (diving).
# The frequency manages the selection of the next node:
# - 1 means that the node with the lowest lower bound is always selected;
# - a value > 1 means that the node with the lowest upper bound is selected
#   when the node counter modulo the frequency is equal to 0.
BB_SPACE_FREQUENCY = 1

# Exploration strategy for branch-and-prune algorithms
# - DFS: Depth-First-Search
# - BFS: Breadth-First-Search
# - DMDFS: Distant-Most Depth-First-Search
BP_NODE_SELECTION = DMDFS

###############################################################################
## SPLITTING STRATEGIES                                                      ##
###############################################################################

# The objective function is represented by a variable and its domain can be
# split or not.
# - YES: it is considered as any other variable;
# - NO:  its domain is not split.
SPLIT_OBJECTIVE = NO

# Variable selection strategy that chooses the next variable to split
# - MAX_DOM:     largest domain
# - MAX_SMEAR:   maximum smear
# - ROUND_ROBIN: round-robin strategy
SPLIT_SELECTOR = MAX_DOM

# Domain splitting strategy
# - BISECTION: divides a domain in two equal parts
# - PEELING:   divides a domain in three parts
#              the width of peels is fixed using SPLIT_PEEL_FACTOR
# - PARTITION: divides a domain in N slices of equal size
#              N is fixed using SPLIT_NB_SLICES
SPLIT_SLICER = BISECTION

# Peel width factor in [0, 100] used by the Peeling-based slicer
SPLIT_PEEL_FACTOR = 10.0

# Number of slices generated by the Partition-based slicer
SPLIT_NB_SLICES = 5

# An inner region can be considered as a solution or it can be split.
# - YES: it is split;
# - NO:  it is considered as a solution.
SPLIT_INNER = YES

###############################################################################
## CONTRACTORS AND PROPAGATION                                               ##
###############################################################################

# Tolerance on the distance between consecutive intervals in a propagator
# Given the interval domain Xk of a variable x at the beginning of the k-th
# iteration and Xk' the reduced domain, the variable is considered as modified
# if the distance between Xk and Xk' is greater than this tolerance and it
# leads to a propagation step with respect to this variable.
# The value is a posiive real number followed by a character: A for an absolute
# or R for a relative tolerance.
PROPAGATION_DTOL = 1.0e-8R

# Iteration limit for the main constraint propagation loop
PROPAGATION_ITER_LIMIT = 50

# Peel factor for the BC3 contractor >= 0.0 and <= 100.0
# Given an interval [a, b] and the peel factor f let w = (b - a) * (p / 100)
# be a ratio of the interval width. Then the consistency of the intervals
# [a, a+w] and [b-w, w] is checked in order to stop the search.
BC3_PEEL_FACTOR = 2.0

# Iteration limit for the iterative method of the BC3 contractor used to find
# the outermost zeros of a function in a given interval
BC3_ITER_LIMIT = 30

# Propagation strategy: the default one is a classical propagation algorithm
# that uses one contractor per constraint
# HC4: HC4 contractor
# BC4: BC4 contractor
PROPAGATION_BASE = HC4

# Now it is possible to increase the contraction power of the algorithm by
# activating strong contractors, as follows:

# Propagation with a max CID contractor (YES or NO)
PROPAGATION_WITH_MAX_CID = YES

# Propagation with a polytope hull contractor
# - NO: contractor not used
# - RLT: contractor based on a RLT-based relaxation
# - AFFINE: contractor based an an affine relaxation
# - TAYLOR: contractor based on a Taylor relaxation
PROPAGATION_WITH_POLYTOPE = NO

###############################################################################
## LOCAL OPTIMIZATION                                                        ##
###############################################################################

# Coefficient of the Armijo rule used to stop a line search optimization
# > 0.0 and < 1.0
LINE_SEARCH_ARMIJO = 0.09375

# Smallest value of the step length of line search algorithm (absolute value)
LINE_SEARCH_STEP_TOL = 1.0e-8

# Iteration limit of line search algorithm
LINE_SEARCH_ITER_LIMIT = 20

# Tolerance on the norm of the gradient in the steepest descent method
GRADIENT_DESCENT_TOL = 1.0e-3

# Time limit in seconds
LOCAL_SOLVER_TIME_LIMIT = 10.0

# Local optimization technique
# - GRADIENT:   gradient descent method
# - EVALUATION: simple test at the midpoint of a region
LOCAL_SOLVER_ALGORITHM = GRADIENT

###############################################################################
## LINEAR PROGRAMMING                                                        ##
###############################################################################

# Time limit in seconds
LP_TIME_LIMIT = 10.0

# Iteration limit
LP_ITER_LIMIT = 50

###############################################################################
## INTERVAL NEWTON                                                           ##
###############################################################################

# Iteration limit
NEWTON_ITER_LIMIT = 20
