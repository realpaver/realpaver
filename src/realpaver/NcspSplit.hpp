/*------------------------------------------------------------------------------
 * Realpaver -- Realpaver is a rigorous nonlinear constraint solver based on
 *              interval computations.
 *------------------------------------------------------------------------------
 * Copyright (c) 2004-2016 Laboratoire d'Informatique de Nantes Atlantique,
 *               France
 * Copyright (c) 2017-2024 Laboratoire des Sciences du Num√©rique de Nantes,
 *               France
 *------------------------------------------------------------------------------
 * Realpaver is a software distributed WITHOUT ANY WARRANTY. Read the COPYING
 * file for information.
 *----------------------------------------------------------------------------*/

/**
 * @file   NcspSplit.hpp
 * @brief  Splitting strategies of NCSP solver
 * @author Laurent Granvilliers
 * @date   2024-4-11
*/

#ifndef REALPAVER_NCSP_SPLIT_HPP
#define REALPAVER_NCSP_SPLIT_HPP

#include <list>
#include "realpaver/DomainSlicerFactory.hpp"
#include "realpaver/NcspContext.hpp"
#include "realpaver/NcspNode.hpp"
#include "realpaver/Scope.hpp"

namespace realpaver {

/**
 * @brief Base class of splitting strategies of NCSP solver.
 * 
 * It stores a scope of variables (the ones whose domains can be split) and a
 * map of slicers.
 * 
 * The  nodes resulting from a splitting step are stored in an iterable
 * container.
 *
 * It manages a counter of node indexes. When a new sub-node is created in the
 * apply method, its index is assigned to the counter value, which is then
 * incremented. In order to reset this counter, the reset method must be called,
 * e.g., before the solving of a new problem.
 */
class NcspSplit {
public:
   /// Constructor
   NcspSplit(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Destructor
   virtual ~NcspSplit();

   /// No copy
   NcspSplit(const NcspSplit&) = delete;

   /// No assignment
   NcspSplit& operator=(const NcspSplit&) = delete;

   /// Returns the scope of this
   Scope scope() const;

   /**
    * @brief Splits a node.
    * 
    * Return true if the given node can be split in at least two sub-nodes,
    * false otherwise.
    *
    * The sub-nodes can be obtained through iterators.
    */
   void apply(SharedNcspNode& node, NcspContext& context);

   /// Returns the number of nodes generated by the last split
   size_t getNbNodes() const;

   /// Returns the number of application of this
   size_t getNbSplits() const;

   /// Resets this
   void reset();

   /// Returns the slicer map
   DomainSlicerMap* getSlicerMap() const;

protected:
   typedef std::list<SharedNcspNode> ContainerType;

   Scope scop_;                  // set of variables
   DomainSlicerMap* slicerMap_;  // slicer of domains
   ContainerType cont_;          // container for the sub-nodes

   /// Implements the splitting method
   virtual void applyImpl(SharedNcspNode& node, NcspContext& context) = 0;

   /// Splits a node given a selected variable
   void splitOne(SharedNcspNode& node, Variable v);

   /// Clones a node, assigns an index to the clone and increments its depth
   SharedNcspNode cloneNode(const SharedNcspNode& node);

private:
   size_t nbs_;   // number of splitting steps
   size_t idx_;   // next node index

public:
   /// Type of iterators on the set of sub-nodes
   using iterator = ContainerType::iterator;

   /// Returns an iterator on the beginning of the container of sub-nodes
   iterator begin();

   /// Returns an iterator on the end of the container of sub-nodes
   iterator end();
};

/*----------------------------------------------------------------------------*/

/// Round-Robin strategy
class NcspSplitRR : public NcspSplit {
public:
   /// Constructor
   NcspSplitRR(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~NcspSplitRR() = default;

   /// No copy
   NcspSplitRR(const NcspSplitRR&) = delete;

   /// No assignment
   NcspSplitRR& operator=(const NcspSplitRR&) = delete;

   void applyImpl(SharedNcspNode& node, NcspContext& context) override;

private:
   // variable selection method
   std::pair<bool, Variable> selectVar(SharedNcspNode& node,
                                       NcspContext& context);
};

/*----------------------------------------------------------------------------*/

/// Largest-First strategy
class NcspSplitLF : public NcspSplit {
public:
   /// Constructor
   NcspSplitLF(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~NcspSplitLF() = default;

   /// No copy
   NcspSplitLF(const NcspSplitLF&) = delete;

   /// No assignment
   NcspSplitLF& operator=(const NcspSplitLF&) = delete;

   void applyImpl(SharedNcspNode& node, NcspContext& context) override;

   /**
    * @brief Variable selection.
    * 
    * Returns a couple (b, v) such that b is false if no variable has been
    * selected, b is true if v has ben selected
    */
   std::pair<bool, Variable> selectVar(SharedNcspNode& node);

   /**
    * @brief Variable selection.
    * 
    * Returns a couple (b, v) such that b is false if no variable has been
    * selected, b is true if v has ben selected
    */
   static std::pair<bool, Variable> selectVar(const Scope& scop,
                                              const DomainBox& box);
};

/*----------------------------------------------------------------------------*/

/// Smallest-First strategy
class NcspSplitSF : public NcspSplit {
public:
   /// Constructor
   NcspSplitSF(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~NcspSplitSF() = default;

   /// No copy
   NcspSplitSF(const NcspSplitSF&) = delete;

   /// No assignment
   NcspSplitSF& operator=(const NcspSplitSF&) = delete;

   void applyImpl(SharedNcspNode& node, NcspContext& context) override;

private:
   // variable selection method
   std::pair<bool, Variable> selectVar(SharedNcspNode& node);
};

/*----------------------------------------------------------------------------*/

/**
 * @brief Splitting strategy for mixed problems.
 *
 * If there is an integer variable whose domain is splitable, then it selects
 * the integer variable having the smallest domain. Otherwise, it selects the
 * real variable having the largest domain.
 */
class NcspSplitSLF : public NcspSplit {
public:
   /// Constructor
   NcspSplitSLF(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~NcspSplitSLF() = default;

   /// No copy
   NcspSplitSLF(const NcspSplitSLF&) = delete;

   /// No assignment
   NcspSplitSLF& operator=(const NcspSplitSLF&) = delete;

   void applyImpl(SharedNcspNode& node, NcspContext& context) override;

private:
   // variable selection method
   std::pair<bool, Variable> selectVar(SharedNcspNode& node);
};

/*----------------------------------------------------------------------------*/

/// Splitting strategy based on Smear Sum Relative values
class NcspSplitSSR : public NcspSplit {
public:
   /// Constructor
   NcspSplitSSR(std::shared_ptr<IntervalSmearSumRel> ssr,
                std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~NcspSplitSSR() = default;

   /// No copy
   NcspSplitSSR(const NcspSplitSSR&) = delete;

   /// No assignment
   NcspSplitSSR& operator=(const NcspSplitSSR&) = delete;

   void applyImpl(SharedNcspNode& node, NcspContext& context) override;

private:
   std::shared_ptr<IntervalSmearSumRel> ssr_;

   // variable selection method
   std::pair<bool, Variable> selectVar(SharedNcspNode& node);
};

} // namespace

#endif
