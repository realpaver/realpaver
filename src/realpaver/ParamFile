###############################################################################
## This file is part of Realpaver, an interval constraint and NLP solver.    ##
##                                                                           ##
## Copyright (c) 2017-2023 LS2N, Nantes                                      ##
##                                                                           ##
## Realpaver is a software distributed WITHOUT ANY WARRANTY; read the file   ##
## COPYING for information.                                                  ##
###############################################################################

# The name of a parameter respects the pattern [A-Z](A-Z0-9_)*

###############################################################################
## GENERAL PARAMETERS                                                        ##
###############################################################################

# Time limit in seconds
TIME_LIMIT = 100.0

# Tolerances (relative, absolute) on the width of an interval domain of a
# constrained variable
VAR_REL_TOL = 0.0
VAR_ABS_TOL = 1.0e-8

# Number of digits used to print floating-point numbers and intervals
FLOAT_PRECISION = 12

# Log level
# NONE:  no log
# MAIN:  main level e.g. display results of first-class algorithms
# INTER: intermediary level e.g. display nodes in a search algorithm
# LOW:   low level e.g. display quantities in iterative methods
# FULL:  verbose mode
LOG_LEVEL = NONE

# Trace displayed in a terminal (YES or NO)
TRACE = YES

# Display of regions
# STD: standard display with one variable and its domain per line
# VEC: display of the vector of domains
DISPLAY_REGION = STD

# Preprocessing phase of the solving process enabled or disabled (YES or NO)
PREPROCESSING = YES

###############################################################################
## BRANCH-AND-CONTRACT ALGORITHMS                                            ##
###############################################################################

# Limit on the number of nodes generated by search algorithms
NODE_LIMIT = 120000

# Limit on the depth of nodes of search trees
DEPTH_LIMIT = 100

# Limit on the number of solutions
SOLUTION_LIMIT = 100

# In a branch-and-bound algorithm, the next node can be either the node with
# the lowest lower bound or the node with the lowest upper bound (diving).
# The frequency manages the selection of the next node:
# - 1 means that the node with the lowest lower bound is always selected;
# - a value > 1 means that the node with the lowest upper bound is selected
#   when the node counter modulo the frequency is equal to 0.
BB_SPACE_FREQUENCY = 1

# Exploration strategy for branch-and-prune algorithms
# - DFS: Depth-First-Search
# - BFS: Breadth-First-Search
# - DMDFS: Distant-Most Depth-First-Search
# - IDFS: Hybrid Best-First Depth-First strategy such that the next node
#         after a DFS stage is a node whose depth in the search tree is minimal
# - PDFS: Hybrid Best-First Depth-First strategy such that the next node
#         after a DFS stage is a node whose perimeter is maximal
# - GPDFS: Hybrid Best-First Depth-First strategy such that the next node
#          after a DFS stage is a node whose grid perimeter is maximal
#
# Assigns SPLIT_INNER = true for DMDFS and the hybrid DFS in order to calculate
# solutions at the given tolerance, and not to consider larger inner boxes
# as solutions
BP_NODE_SELECTION = DFS

# Limit on the gap between two solutions such that they are aggregated
# if they are close enough.
# The value is:
# - negative if no clustering is required;
# - 0.0 if two solutions are aggregated if they overlap;
# - positive otherwise; in particular, a huge value may permit to calculate
#   the hull of all the solutions.
SOLUTION_CLUSTER_GAP = 0.0

###############################################################################
## SPLITTING STRATEGIES                                                      ##
###############################################################################

# The objective function is represented by a variable and its domain can be
# split or not.
# - YES: it is considered as any other variable;
# - NO:  its domain is not split.
SPLIT_OBJECTIVE = NO

# Variable selection strategy that chooses the next variable to split
# - RR:       round-robin strategy
# - LF:       largest domain
# - SF:       smallest domain
# - SSR:      smear sum relative (using derivatives)
# - MIXED_SLF integer variable with smallest first and then real variable
#             with largest domain
SPLIT_SELECTOR = RR

# Domain splitting strategy
# - BISECTION: divides a domain in two equal parts
SPLIT_SLICER = BISECTION

# An inner region can be considered as a solution or it can be split.
# - YES: it is split;
# - NO:  it is considered as a solution.
SPLIT_INNER = NO

###############################################################################
## CONTRACTORS AND PROPAGATION                                               ##
###############################################################################

# Tolerance in [0,1] that corresponds to a percentage of reduction of the
# width of a box driving propagation steps. Given two consecutive domains
# prev and next of some variable and tol the tolerance, a propagation on this
# variable occurs if (1 - width(next) / width(prev)) > tol.
PROPAGATION_REL_TOL = 1.0e-3

# Iteration limit for the main constraint propagation loop
PROPAGATION_ITER_LIMIT = 50

# Peel factor for the BC3 contractor >= 0.0 and <= 100.0
# Given an interval [a, b] and the peel factor f let w = (b - a) * (p / 100)
# be a ratio of the interval width. Then the consistency of the intervals
# [a, a+w] and [b-w, w] is checked in order to stop the search.
BC3_PEEL_FACTOR = 2.0

# Iteration limit for the iterative method of the BC3 contractor used to find
# the outermost zeros of a function in a given interval
BC3_ITER_LIMIT = 30

# Propagation strategy: the default one is a classical propagation algorithm
# that uses one contractor per constraint
# HC4:   HC4 contractor
# BC4:   BC4 contractor
# ACID : ACID contractor
PROPAGATION_BASE = HC4

# Propagation with a polytope hull contractor
# - NO: contractor not used
# - RLT: contractor based on a RLT-based relaxation
# - TAYLOR: contractor based on a Taylor relaxation
PROPAGATION_WITH_POLYTOPE = NO

# Propagation with the interval Newton method applied to a square system
# of equations (YES or NO)
PROPAGATION_WITH_NEWTON = NO

# Positive real number eps used to relax an equation c(x)=0 as |l(x)| <= eps
# where l(x) is generated by a relaxation method.
# The value 0.0 implies that a linear equation is generated.
RELAXATION_EQ_TOL = 1.0e-10

###################################################
# Adaptive Constructive Interval Disjunction (ACID)
# Parameters used if PROPAGATION_BASE = ACID

# Number of slices of a domain handled by var3B contractors
NB_SLICE_3B = 7

# Number of slices of a domain handled by varCID contractors
NB_SLICE_CID = 3

# Number of consecutive nodes handled in the learning phase of ACID
LEARN_LENGTH_ACID = 50

# Number of nodes in a learning phase and an exploitation phase of ACID
CYCLE_LENGTH_ACID = 1000

# Gain ratio between two consecutive boxes handed by var3BCID contractors
# in ACID. It is used to adapt the nuber of var3BCID contractors that are
# applied in the contraction procedure.
CT_RATIO_ACID = 0.002

###############################################################################
## LOCAL OPTIMIZATION                                                        ##
###############################################################################

# Algorithm implemented by the NLP solver
# - DEFAULT: default algorithm
# - NLOPT_NELDERMEAD: derivative-free unconstrained local optimization using NlOpt
# - NLOPT_BOBYQA: derivative-free unconstrained local optimization using NlOpt
# - NLOPT_MMA: gradient-based constrained local optimization using NlOpt
# - NLOPT_SLSQP: gradient-based constrained local optimization using NlOpt
NLP_SOLVER_ALGORITHM = DEFAULT

# Time limit in seconds
NLP_SOLVER_TIME_LIMIT = 10.0

# Iteration limit
NLP_SOLVER_ITER_LIMIT = 100

# Tolerances (relative, absolute) on the objective function
NLP_SOLVER_OBJ_REL_TOL = 1.0e-4
NLP_SOLVER_OBJ_ABS_TOL = 0.0

###############################################################################
## LINEAR SOLVERS                                                            ##
###############################################################################

# Time limit in seconds
LP_TIME_LIMIT = 10.0

# Iteration limit
LP_ITER_LIMIT = 50

# Threshold on the values of pivots in Gaussian elimination
# A pivot must be strictly greater than this (positive) value.
GAUSSIAN_MIN_PIVOT = 1.0e-8

###############################################################################
## INTERVAL ALGORITHMS                                                       ##
###############################################################################

# Iteration limit for the univariate interval Newton method
UNI_NEWTON_ITER_LIMIT = 20

# Iteration limit on the number of steps in the interval Gauss-Seidel method
GAUSS_SEIDEL_ITER_LIMIT = 50

# Tolerance in [0,1] that corresponds to a percentage of reduction of the
# width of an interval vector. Given two consecutive domains prev and next of
# some variable and tol the tolerance, the method is iterated if we have
#(1 - width(next) / width(prev)) > tol.
GAUSS_SEIDEL_REL_TOL = 1.0e-3

# Iteration limit on the number of (outer) steps in the contraction technique
# of interval Newton method
NEWTON_ITER_LIMIT = 30

# Iteration limit on the number of (outer) steps in the certification technique
# of the interval Newton method
NEWTON_CERTIFY_ITER_LIMIT = 20

# Tolerance in [0,1] that corresponds to a percentage of reduction of the
# width of a box. Given two consecutive domains prev and next of some
# variable and tol the tolerance, the method is iterated if we have
#(1 - width(next) / width(prev)) > tol.
NEWTON_REL_TOL = 1.0e-3

# Let x be an interval and let m(x) be its midpoint. An inflation of x returns
# m(x) + delta*(x - m(x)) + chi*[-1,1]. The following parameter delta is a real
# number > 1.0.
INFLATION_DELTA = 1.125

# Let x be an interval and let m(x) be its midpoint. An inflation of x returns
# m(x) + delta*(x - m(x)) + chi*[-1,1]. The following parameter chi is a small
# real number > 0.0 which is necessary to inflate degenerated intervals.
# intervals. 
INFLATION_CHI = 1.0e-12
