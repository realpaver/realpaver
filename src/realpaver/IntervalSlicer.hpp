/*------------------------------------------------------------------------------
 * Realpaver -- Realpaver is a rigorous nonlinear constraint solver based on
 *              interval computations.
 *------------------------------------------------------------------------------
 * Copyright (c) 2004-2016 Laboratoire d'Informatique de Nantes Atlantique,
 *               France
 * Copyright (c) 2017-2024 Laboratoire des Sciences du Num√©rique de Nantes,
 *               France
 *------------------------------------------------------------------------------
 * Realpaver is a software distributed WITHOUT ANY WARRANTY. Read the COPYING
 * file for information.
 *----------------------------------------------------------------------------*/

/**
 * @file   IntervalSlicer.hpp
 * @brief  Interval slicers
 * @author Laurent Granvilliers
 * @date   2024-4-11
*/

#ifndef REALPAVER_INTERVAL_SLICER_HPP
#define REALPAVER_INTERVAL_SLICER_HPP

#include <list>
#include "realpaver/Interval.hpp"

namespace realpaver {

/**
 * @brief Base class of interval slicers.
 * 
 * A slicer generates a partition of an interval. The slices stored in a
 * container in this object can be obtained through iterators.
 */
class IntervalSlicer {
public:
   /// Default constructor
   IntervalSlicer() = default;

   /// Destructor
   virtual ~IntervalSlicer();

   /// Default copy constructor
   IntervalSlicer(const IntervalSlicer&) = default;

   /// Default assignment operator
   IntervalSlicer& operator=(const IntervalSlicer&) = default;

   /**
    * @brief Slices x and returns the number of slices.
    * 
    * This method calls applyImpl(x) that must be implementd in a sub-class.
    */
   size_t apply(const Interval& x);

   /// Returns the number of slices generated by apply(x)
   size_t nbSlices() const;

protected:
   /// Implements the slicing method
   virtual void applyImpl(const Interval& x) = 0;

   /// Inserts an interval in the container
   void push(const Interval& x);

   /// Clears the container
   void clear();

private:
   using ContainerType = std::list<Interval>;
   ContainerType cont_;

public:
   /// Iterators on the set of slices
   using iterator = ContainerType::iterator;

   /// Returns an iterator on the first slice
   iterator begin();

   /// Returns an iterator on the end of the container of slices
   iterator end();

   /// Reverse iterators on the set of slices
   using reverse_iterator = ContainerType::reverse_iterator;

   /// Returns a reverse iterator on the last slice
   reverse_iterator rbegin();

   /// Returns a reverse iterator on the reverse end of the container of slices
   reverse_iterator rend();
};

/*----------------------------------------------------------------------------*/

/// Slicer that bisects an interval
class IntervalBisecter : public IntervalSlicer {
public:
   void applyImpl(const Interval& x) override;
};

/*----------------------------------------------------------------------------*/

/**
 * @brief Slicer that divides an interval in three parts.
 * 
 *  Given an interval [a,b] and a factor 0 < f < 100, it calculates the
 *  w = (f / 100) * (b-a), which is a proportion of the width of [a,b].
 *  Then it generates three intervals [a,a+w], [a+w,b-w], [b-w,b]. The
 *  slice [a,a+w] is the left peel and [b-w,b] is the right peel.
 */
class IntervalPeeler : public IntervalSlicer {
public:
   /// Creates a slicer given a width factor f
   IntervalPeeler(double f);

   /// Returns the width factor
   double getFactor() const;

   /// Sets the width factor
   void setFactor(double f);

   /// Returns the left peel of x
   Interval peelLeft(const Interval& x) const;

   /// Returns the right peel of x
   Interval peelRight(const Interval& x) const;

   void applyImpl(const Interval& x) override;

private:
   double f_;     // factor
   Interval p_;   // f_ / 100
};

/*----------------------------------------------------------------------------*/

/**
 * @brief Slicer that divides an interval in several parts of equal size.
 * 
 *  Given an interval [a,b] and a number of slices n, it generates the sequence
 *  [a,a+h], [a+h,a+2h], ..., [b-h,b] where h is obtained as the width of [a,b]
 *  divided by n. The number n is called arity.
 */
class IntervalPartitionMaker : public IntervalSlicer {
public:
   /// Creates a slicer given a number of slices (arity)
   IntervalPartitionMaker(size_t n = 2);

   /// Return the arity of this
   size_t getArity() const;

   /// Sets the arity of this
   void setArity(size_t n);

   void applyImpl(const Interval& x) override;

private:
   size_t n_;
};

} // namespace

#endif
