/*------------------------------------------------------------------------------
 * Realpaver -- Realpaver is a rigorous nonlinear constraint solver based on
 *              interval computations.
 *------------------------------------------------------------------------------
 * Copyright (c) 2004-2016 Laboratoire d'Informatique de Nantes Atlantique,
 *               France
 * Copyright (c) 2017-2024 Laboratoire des Sciences du Num√©rique de Nantes,
 *               France
 *------------------------------------------------------------------------------
 * Realpaver is a software distributed WITHOUT ANY WARRANTY. Read the COPYING
 * file for information.
 *----------------------------------------------------------------------------*/

/**
 * @file   CSPSplit.hpp
 * @brief  Splitting strategies of CSP solver
 * @author Laurent Granvilliers
 * @date   2024-4-11
 */

#ifndef REALPAVER_CSP_SPLIT_HPP
#define REALPAVER_CSP_SPLIT_HPP

#include "realpaver/CSPContext.hpp"
#include "realpaver/CSPNode.hpp"
#include "realpaver/DomainSlicerFactory.hpp"
#include "realpaver/IntervalSmearSumRel.hpp"
#include "realpaver/Scope.hpp"
#include <list>

namespace realpaver {

/**
 * @brief Base class of splitting strategies of CSP solver.
 *
 * It stores a scope of variables (the ones whose domains can be split) and a
 * map of slicers.
 *
 * The  nodes resulting from a splitting step are stored in an iterable
 * container.
 *
 * It manages a counter of node indexes. When a new sub-node is created in the
 * apply method, its index is assigned to the counter value, which is then
 * incremented. In order to reset this counter, the reset method must be called,
 * e.g., before the solving of a new problem.
 */
class CSPSplit {
public:
   /// Constructor
   CSPSplit(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Destructor
   virtual ~CSPSplit();

   /// No copy
   CSPSplit(const CSPSplit &) = delete;

   /// No assignment
   CSPSplit &operator=(const CSPSplit &) = delete;

   /// Returns the scope of this
   Scope scope() const;

   /**
    * @brief Splits a node.
    *
    * Return true if the given node can be split in at least two sub-nodes,
    * false otherwise.
    *
    * The sub-nodes can be obtained through iterators.
    */
   void apply(SharedCSPNode &node, CSPContext &context);

   /// Returns the number of nodes generated by the last split
   size_t getNbNodes() const;

   /// Returns the number of application of this
   size_t getNbSplits() const;

   /// Resets this
   void reset();

   /// Returns the slicer map
   DomainSlicerMap *getSlicerMap() const;

protected:
   typedef std::list<SharedCSPNode> ContainerType;

   Scope scop_;                 // set of variables
   DomainSlicerMap *slicerMap_; // slicer of domains
   ContainerType cont_;         // container for the sub-nodes

   /// Implements the splitting method
   virtual void applyImpl(SharedCSPNode &node, CSPContext &context) = 0;

   /// Splits a node given a selected variable
   void splitOne(SharedCSPNode &node, Variable v);

   /// Clones a node, assigns an index to the clone and increments its depth
   SharedCSPNode cloneNode(const SharedCSPNode &node);

private:
   size_t nbs_; // number of splitting steps
   size_t idx_; // next node index

public:
   /// Type of iterators on the set of sub-nodes
   using iterator = ContainerType::iterator;

   /// Returns an iterator on the beginning of the container of sub-nodes
   iterator begin();

   /// Returns an iterator on the end of the container of sub-nodes
   iterator end();
};

/*----------------------------------------------------------------------------*/

/// Round-Robin strategy
class CSPSplitRR : public CSPSplit {
public:
   /// Constructor
   CSPSplitRR(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~CSPSplitRR() = default;

   /// No copy
   CSPSplitRR(const CSPSplitRR &) = delete;

   /// No assignment
   CSPSplitRR &operator=(const CSPSplitRR &) = delete;

   void applyImpl(SharedCSPNode &node, CSPContext &context) override;

private:
   // variable selection method
   std::pair<bool, Variable> selectVar(SharedCSPNode &node, CSPContext &context);
};

/*----------------------------------------------------------------------------*/

/// Largest-First strategy
class CSPSplitLF : public CSPSplit {
public:
   /// Constructor
   CSPSplitLF(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~CSPSplitLF() = default;

   /// No copy
   CSPSplitLF(const CSPSplitLF &) = delete;

   /// No assignment
   CSPSplitLF &operator=(const CSPSplitLF &) = delete;

   void applyImpl(SharedCSPNode &node, CSPContext &context) override;

   /**
    * @brief Variable selection.
    *
    * Returns a couple (b, v) such that b is false if no variable has been
    * selected, b is true if v has ben selected
    */
   std::pair<bool, Variable> selectVar(SharedCSPNode &node);

   /**
    * @brief Variable selection.
    *
    * Returns a couple (b, v) such that b is false if no variable has been
    * selected, b is true if v has ben selected
    */
   static std::pair<bool, Variable> selectVar(const Scope &scop, const DomainBox &box);
};

/*----------------------------------------------------------------------------*/

/// Smallest-First strategy
class CSPSplitSF : public CSPSplit {
public:
   /// Constructor
   CSPSplitSF(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~CSPSplitSF() = default;

   /// No copy
   CSPSplitSF(const CSPSplitSF &) = delete;

   /// No assignment
   CSPSplitSF &operator=(const CSPSplitSF &) = delete;

   void applyImpl(SharedCSPNode &node, CSPContext &context) override;

private:
   // variable selection method
   std::pair<bool, Variable> selectVar(SharedCSPNode &node);
};

/*----------------------------------------------------------------------------*/

/**
 * @brief Splitting strategy for mixed problems.
 *
 * If there is an integer variable whose domain is splitable, then it selects
 * the integer variable having the smallest domain. Otherwise, it selects the
 * real variable having the largest domain.
 */
class CSPSplitSLF : public CSPSplit {
public:
   /// Constructor
   CSPSplitSLF(Scope scop, std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~CSPSplitSLF() = default;

   /// No copy
   CSPSplitSLF(const CSPSplitSLF &) = delete;

   /// No assignment
   CSPSplitSLF &operator=(const CSPSplitSLF &) = delete;

   void applyImpl(SharedCSPNode &node, CSPContext &context) override;

private:
   // variable selection method
   std::pair<bool, Variable> selectVar(SharedCSPNode &node);
};

/*----------------------------------------------------------------------------*/

/// Splitting strategy based on Smear Sum Relative values
class CSPSplitSSR : public CSPSplit {
public:
   /// Constructor
   CSPSplitSSR(std::shared_ptr<IntervalSmearSumRel> ssr,
               std::unique_ptr<DomainSlicerMap> smap);

   /// Default destructor
   ~CSPSplitSSR() = default;

   /// No copy
   CSPSplitSSR(const CSPSplitSSR &) = delete;

   /// No assignment
   CSPSplitSSR &operator=(const CSPSplitSSR &) = delete;

   void applyImpl(SharedCSPNode &node, CSPContext &context) override;

private:
   std::shared_ptr<IntervalSmearSumRel> ssr_;

   // variable selection method
   std::pair<bool, Variable> selectVar(SharedCSPNode &node);
};

} // namespace realpaver

#endif
