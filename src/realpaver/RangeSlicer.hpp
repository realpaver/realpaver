///////////////////////////////////////////////////////////////////////////////
// This file is part of Realpaver, an interval constraint and NLP solver.    //
//                                                                           //
// Copyright (c) 2017-2022 LS2N, Nantes                                      //
//                                                                           //
// Realpaver is a software distributed WITHOUT ANY WARRANTY; read the file   //
// COPYING for information.                                                  //
///////////////////////////////////////////////////////////////////////////////

#ifndef REALPAVER_RANGE_SLICER_HPP
#define REALPAVER_RANGE_SLICER_HPP

#include <list>
#include "realpaver/Range.hpp"

namespace realpaver {

///////////////////////////////////////////////////////////////////////////////
/// This is a base class of range slicers.
///
/// A slicer generates a partition of a range. The slices can be obtained
/// through iterators.
///////////////////////////////////////////////////////////////////////////////
class RangeSlicer {
public:
   /// Default constructor
   RangeSlicer() = default;

   /// Default copy constructor
   RangeSlicer(const RangeSlicer&) = default;

   /// Default assignment operator
   RangeSlicer& operator=(const RangeSlicer&) = default;

   /// Destructor
   virtual ~RangeSlicer();

   /// Slices a range
   /// @param x a range
   /// @return the number of slices
   ///
   /// This method calls applyImpl(x).
   size_t apply(const Range& x);

   /// @return the number of slices generated by apply(x)
   size_t nbSlices() const;

protected:
   /// Implements the slicing method
   virtual void applyImpl(const Range& x) = 0;

   /// Inserts an interval in the container
   void push(const Range& x);

   /// Clears the container
   void clear();

private:
   typedef std::list<Range> ContainerType;
   ContainerType cont_; 

public:
   /// Iterators on the set of slices
   typedef typename ContainerType::iterator iterator;

   /// @returns an iterator on the beginning of the container of slices
   iterator begin();

   /// @returns an iterator on the end of the container of slices
   iterator end();
};

///////////////////////////////////////////////////////////////////////////////
/// This bisects a range.
///
/// [a,b] -> [a,m], [m+1,b] (midpoint m)
///////////////////////////////////////////////////////////////////////////////
class RangeBisecter : public RangeSlicer {
public:
   void applyImpl(const Range& x) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This divides a range in three parts.
///
/// [a,b] -> [a,a], [a+1,b-1], [b,b]
///////////////////////////////////////////////////////////////////////////////
class RangePeeler : public RangeSlicer {
public:
   void applyImpl(const Range& x) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This divides a range in two parts: [a,b] -> [a,a], [a+1,b]
///////////////////////////////////////////////////////////////////////////////
class RangeLeftFixer : public RangeSlicer {
public:
   void applyImpl(const Range& x) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This divides a range in two parts: [a,b] -> [a,b-1], [b,b]
///////////////////////////////////////////////////////////////////////////////
class RangeRightFixer : public RangeSlicer {
public:
   void applyImpl(const Range& x) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This generates a partition with only one element in each element.
///
/// [a,b] -> [a,a], [a+1,a+1], ..., [b,b]
///////////////////////////////////////////////////////////////////////////////
class RangeSprayer : public RangeSlicer {
public:
   void applyImpl(const Range& x) override;
};

} // namespace

#endif
