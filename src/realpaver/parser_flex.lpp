%{
#include <stdio.h>
#include "realpaver/parser_bison.hpp"
#include "realpaver/Problem.hpp"
#include "realpaver/SymbolTable.hpp"

extern int realpaver_bison_lineno;
%}

%option prefix = "realpaver_bison_"
%option nounput

SPACE       [ \t\r]+
IDENT       [a-zA-Z][a-zA-Z0-9_]*
DIG         [0-9]
INT         {DIG}+
E           [eE][+-]?{DIG}+
REAL        ({DIG}+{E}|{DIG}*"."{DIG}+({E})?|{DIG}+"."{DIG}*({E})?)

%%
{INT}           return TK_INT;
{REAL}          return TK_REAL;

"Variables"     return TK_STR_VAR;
"Constants"     return TK_STR_CONST;
"Constraints"   return TK_STR_CTR;
"Objectives"    return TK_STR_OBJ;
"Functions"     return TK_STR_FUN;

"real"   return TK_STR_REAL;
"int"    return TK_STR_INT;

"min"    return TK_MIN;
"max"    return TK_MAX;
"MIN"    return TK_MIN;
"MAX"	   return TK_MAX;
"sqrt"	return TK_SQRT;
"log"    return TK_LOG;
"exp"    return TK_EXP;
"tan"    return TK_TAN;
"cos"    return TK_COS;
"sin"    return TK_SIN;
"sgn"    return TK_SGN;
"abs"    return TK_ABS;

"in"     return TK_IN;

"+"      return TK_PLUS;
"-"      return TK_MINUS;
"*"      return TK_MUL;
"/"      return TK_DIV;
"^"      return TK_POW;
"("      return TK_LPAR;
")"      return TK_RPAR;
"["      return TK_LSBR;
"]"      return TK_RSBR;
","      return TK_COMMA;
";"      return TK_SCOLON;
":"      return TK_COLON;
">"      return TK_GT;
"<"      return TK_LT;
"="      return TK_EQ;
">="     return TK_GE;
"<="     return TK_LE;

{IDENT}     	return TK_IDENT;

"\n"     { ++realpaver_bison_lineno; }

{SPACE}  {}

"/*"     {
            int c;
            for( ;; )
            {
               while( (c=getchar()) != '*' && c!=EOF )
               {
                  if( c=='\n' ) ++realpaver_bison_lineno;
               }

               if( c=='*' )
               {
                  while( (c=getchar()) == '*' )
                  {
                     if( c=='\n' ) ++realpaver_bison_lineno;
                  }

                  if( c=='/' ) break;
                  if( c=='\n' ) ++realpaver_bison_lineno;
               }
               if( c==EOF ) break;
            }
         }

"//"     {
            int c;
            while( (c=getchar()) != '\n' && (c!=EOF) )
            {}
            if( c=='\n' ) ++realpaver_bison_lineno;
         }
%%

realpaver::Problem* realpaver_bison_problem;
realpaver::SymbolTable* realpaver_bison_symtab;

YY_BUFFER_STATE realpaver_bison_buffer;
std::string realpaver_parse_error;

void realpaver_flex_init(realpaver::Problem* prob,
							    realpaver::SymbolTable* symtab)
{
  realpaver_bison_lineno = 1;
  realpaver_bison_problem = prob;
  realpaver_bison_symtab = symtab;
  realpaver_parse_error = "";
}

void realpaver_flex_init_str(realpaver::Problem* prob,
								     realpaver::SymbolTable* symtab, const char* str)
{
  realpaver_flex_init(prob, symtab);
  realpaver_bison_buffer = realpaver_bison__scan_string(str);
}

int realpaver_flex_init_file(realpaver::Problem* prob,
								     realpaver::SymbolTable* symtab,
								     const char* filename)
{
  int res = 0;
  realpaver_bison_in = fopen(filename, "r");
  if (!realpaver_bison_in)
  {
    realpaver_parse_error = "File not found";
    res = 1;
  }
  else
  {
    realpaver_flex_init(prob, symtab);
    realpaver_bison_buffer =
      realpaver_bison__create_buffer(realpaver_bison_in, YY_BUF_SIZE);
    realpaver_bison__switch_to_buffer(realpaver_bison_buffer);
  }
  return res;
}

void realpaver_flex_cleanup_str()
{
  realpaver_bison_problem = NULL;
  realpaver_bison_symtab = NULL;
  realpaver_bison__delete_buffer(realpaver_bison_buffer);
}

void realpaver_flex_cleanup_file()
{
  realpaver_bison_problem = NULL;
  realpaver_bison_symtab = NULL;
  if (realpaver_bison_in)
  {
    fclose(realpaver_bison_in);
    realpaver_bison__delete_buffer(realpaver_bison_buffer);
  }
}

int realpaver_bison_wrap(void)
{
  return 1;
}
