///////////////////////////////////////////////////////////////////////////////
// This file is part of Realpaver, an interval constraint and NLP solver.    //
//                                                                           //
// Copyright (c) 2017-2022 LS2N, Nantes                                      //
//                                                                           //
// Realpaver is a software distributed WITHOUT ANY WARRANTY; read the file   //
// COPYING for information.                                                  //
///////////////////////////////////////////////////////////////////////////////

#ifndef REALPAVER_NCSP_SPACE_HPP
#define REALPAVER_NCSP_SPACE_HPP

#include <vector>
#include "realpaver/NcspNode.hpp"

namespace realpaver {

///////////////////////////////////////////////////////////////////////////////
/// This is the base class of spaces generated by branch-and-prune algorithms
/// for solving Numerical CSPs.
///
/// Two sorts of nodes are stored. The final nodes that are not fathomed during
/// the search (the solutions) are stored in this following a FIFO strategy.
/// The pending or unexplored nodes are managed by a strategy whose interface
/// is defined here. Concrete strategies are implemented in sub-classes.
///////////////////////////////////////////////////////////////////////////////
class NcspSpace {
public:
   /// Constructor
   NcspSpace();

   /// Virtual destructor
   virtual ~NcspSpace();

   /// No assignment
   NcspSpace& operator=(const NcspSpace&) = delete;

   /// Default copy constructor
   NcspSpace(const NcspSpace&) = default;

   /// @return the number of solution nodes of this
   size_t nbSolutionNodes() const;

   /// @param i a solution node index with 0 <= i < nbSolutionNodes()
   /// @return the i-th final node
   SharedNcspNode getSolutionNode(size_t i) const;

   /// Inserts a solution node in this following a FIFO strategy
   /// @para node node inserted
   void pushSolutionNode(const SharedNcspNode& node);

   /// Removes the last soliution node from this
   /// @return the last solution node
   SharedNcspNode popSolutionNode();

   /// @return true if there is a feasible or inner solution node
   bool proofFeasible() const;

   /// @return the number of pending nodes of this
   virtual size_t nbPendingNodes() const = 0;

   /// Extracts the next pending node from this
   /// @return the pending node extracted from this
   virtual SharedNcspNode extractPendingNode() = 0;

   /// Inserts a pending node in this
   virtual void insertPendingNode(const SharedNcspNode& node) = 0;

private:
   std::vector<SharedNcspNode> vnode_;        // vector of solution nodes
   bool feasible_;  // true if there is a feasible or inner solution node
};

} // namespace

#endif
