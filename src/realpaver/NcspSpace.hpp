///////////////////////////////////////////////////////////////////////////////
// This file is part of Realpaver, an interval constraint and NLP solver.    //
//                                                                           //
// Copyright (c) 2017-2023 LS2N, Nantes                                      //
//                                                                           //
// Realpaver is a software distributed WITHOUT ANY WARRANTY; read the file   //
// COPYING for information.                                                  //
///////////////////////////////////////////////////////////////////////////////

#ifndef REALPAVER_NCSP_SPACE_HPP
#define REALPAVER_NCSP_SPACE_HPP

#include <vector>
#include "realpaver/NcspNode.hpp"
#include "realpaver/NcspSplit.hpp"

namespace realpaver {

///////////////////////////////////////////////////////////////////////////////
/// This is the base class of spaces generated by branch-and-prune algorithms
/// for solving Numerical CSPs.
///
/// Two sorts of nodes are stored. The final nodes that are not fathomed during
/// the search (the solutions) are stored in this following a FIFO strategy.
/// The pending or unexplored nodes are managed by a strategy whose interface
/// is defined here. Concrete strategies are implemented in sub-classes.
///////////////////////////////////////////////////////////////////////////////
class NcspSpace {
public:
   /// Default constructor
   NcspSpace() = default;

   /// Virtual destructor
   virtual ~NcspSpace();

   /// No assignment
   NcspSpace& operator=(const NcspSpace&) = delete;

   /// Default copy constructor
   NcspSpace(const NcspSpace&) = default;

   /// Management of solution nodes
   ///@{
   /// @return the number of solution nodes of this
   virtual size_t nbSolNodes() const = 0;

   /// Inserts a solution node in this
   /// @param node node inserted
   virtual void pushSolNode(const SharedNcspNode& node) = 0;

   /// Removes a solution node from this
   /// @return a solution node
   virtual SharedNcspNode popSolNode() = 0;

   /// @param i a solution node index with 0 <= i < nbSolNodes()
   /// @return the i-th solution node
   virtual SharedNcspNode getSolNode(size_t i) const = 0;

   /// @return true if there is a soltion node whose region is an inner region
   ///         or a feasible region
   virtual bool hasFeasibleSolNode() const = 0;

   /// Aggregates the solutions that are close enough
   /// @param gap two solutions are aggregated if their inter-gap is less than
   ///        the value of gap
   ///
   /// If gap < 0.0 then there is no clustering; if gap = 0.0 then two solutions
   /// are replaced by their hull if they overlap; otherwise two solutions
   /// are replaced by their hull if their inter-gap is small enough.
   virtual void makeSolClusters(double gap) = 0;

   /// @return the total number of solution nodes that have been inserted in this
   virtual size_t nbTotalSolNodes() const = 0;
   ///@}

   /// Management of pending nodes
   ///@{
   /// @return the number of pending nodes of this
   virtual size_t nbPendingNodes() const = 0;

   /// Extracts the next pending node from this
   /// @return the pending node extracted from this
   virtual SharedNcspNode nextPendingNode() = 0;

   /// Inserts a pending node in this
   /// @param node node inserted in this
   virtual void insertPendingNode(const SharedNcspNode& node) = 0;

   /// Inserts a collection of pending nodes in this
   /// @param first iterator on the first node
   /// @param last iterator after the last node
   ///
   /// The default behavior calls insertPendingNode for each node in
   /// the range of iterators.
   virtual void insertPendingNodes(NcspSplit::iterator first,
                                   NcspSplit::iterator last);

   /// @param i a pending node index with 0 <= i < nbPendingNodes()
   /// @return the i-th pending node
   virtual SharedNcspNode getPendingNode(size_t i) const = 0;

   /// @return the hull of all the pending nodes
   ///
   /// throws an exception if there is no pending node
   IntervalRegion hullOfPendingNodes() const;
   ///@}
};

} // namespace

#endif
