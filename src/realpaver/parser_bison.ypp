%{
#include <cstring>
#include <sstream>
#include <string>
#include "realpaver/Problem.hpp"
#include "realpaver/SymbolTable.hpp"

#undef YYINITDEPTH
#define YYINITDEPTH 5000

extern char* realpaver_bison_text;
extern int realpaver_bison_lineno;
extern std::string realpaver_parse_error;
extern realpaver::Problem* realpaver_bison_problem;
extern realpaver::SymbolTable* realpaver_bison_symtab;

extern int realpaver_bison_lex(void);
int realpaver_bison_error(const char* str);

extern realpaver::FunctionSymbol* realpaver_fun_symbol;
%}

%define api.prefix {realpaver_bison_}

%code requires
{
#include "realpaver/Constraint.hpp"
#include "realpaver/Exception.hpp"
}

%union
{
  char u_str[256];
  realpaver::TermRep* u_term;
}

%type <u_str>     ident
%type <u_term>    expr
%type <u_term>    const_expr
%type <u_term>    fun_call
%type <u_term>    integer
%type <u_term>    real
%type <u_term>    exponent
%type <u_term>    itv
%type <u_term>    domain

%token TK_IDENT TK_INT TK_REAL
%token TK_STR_VAR TK_STR_CONST TK_STR_CTR TK_STR_OBJ TK_STR_FUN TK_STR_ALIAS
%token TK_STR_INT
%token TK_EQ TK_EQ_EQ TK_LE TK_GE TK_IN TK_LT TK_GT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV
%token TK_POW TK_CARET TK_SQR TK_SQRT TK_LOG TK_EXP
%token TK_TAN TK_COS TK_SIN
%token TK_LPAR TK_RPAR TK_LSBR TK_RSBR TK_PIPE
%token TK_COMMA TK_SCOLON TK_COLON
%token TK_SGN TK_ABS TK_MIN TK_MAX

%left TK_PLUS TK_MINUS
%left TK_MUL TK_DIV
%right TK_UMINUS
%right TK_UPLUS
%right TK_POW

%start model

%%
model
  : 
  | statement TK_SCOLON model
  ;

statement
  : const_statement
  | var_statement
  | alias_statement
  | ctr_statement
  | obj_statement
  | fun_statement
  | int_statement
  ;

const_statement
  : TK_STR_CONST const_list
  ;

const_list
  : const_def const_tail
  ;

const_tail
  :
  | TK_COMMA const_list
  ;

const_def
  : ident TK_EQ const_expr
    {
      realpaver::Term::SharedRep e($3);

      realpaver::Interval x = e->evalConst();
      if (x.isEmpty())
      {
        std::ostringstream os;
        os << "Constant [" << $1 << "] equal to an empty interval";
        realpaver_bison_error(os.str().c_str());
        YYABORT;
      }

      if (realpaver_bison_symtab->hasSymbol($1))
      {
        std::ostringstream os;
        os << "Symbol [" << $1 << "] already used";
        realpaver_bison_error(os.str().c_str());
        YYABORT;         
      }

      realpaver_bison_symtab->insertConstant($1, x);
    }
  ;

var_statement
  : TK_STR_VAR var_list
  ;

var_list
  : var_def var_tail
  ;

var_tail
  :
  | TK_COMMA var_list
  ;

var_def
  : ident domain
    {
      realpaver::Term::SharedRep e($2);
      realpaver::Interval x = e->evalConst();

      if (realpaver_bison_symtab->hasSymbol($1))
      {
        std::ostringstream os;
        os << "Symbol [" << $1 << "] already used";
        realpaver_bison_error(os.str().c_str());
        YYABORT;         
      }

      realpaver::Variable v = realpaver_bison_problem->addRealVar(x, $1);
      realpaver_bison_symtab->insertVariable($1, v);
    }
  ;

alias_statement
  : TK_STR_ALIAS alias_list
  ;

alias_list
  : alias_def alias_tail
  ;

alias_tail
  :
  | TK_COMMA alias_list
  ;

alias_def
  : ident TK_EQ expr
    {
      realpaver::Term t(realpaver::Term::SharedRep($3));

      if (realpaver_bison_symtab->hasSymbol($1))
      {
        std::ostringstream os;
        os << "Symbol [" << $1 << "] already used";
        realpaver_bison_error(os.str().c_str());
        YYABORT;         
      }

      realpaver_bison_symtab->insertAlias($1, t);
    }
  ;

ctr_statement
  : TK_STR_CTR ctr_list
  ;

ctr_list
  : ctr_def ctr_tail
  ;

ctr_tail
  :
  | TK_COMMA ctr_list
  ;

ctr_def
  : expr TK_EQ_EQ expr
    {
      realpaver::Term lhs(realpaver::Term::SharedRep($1));
      realpaver::Term rhs(realpaver::Term::SharedRep($3));

      realpaver::Constraint c(lhs == rhs);
      realpaver_bison_problem->addCtr(c);
    }
  | expr TK_LE expr
    {
      realpaver::Term lhs(realpaver::Term::SharedRep($1));
      realpaver::Term rhs(realpaver::Term::SharedRep($3));

      realpaver::Constraint c(lhs <= rhs);
      realpaver_bison_problem->addCtr(c);
    }
  | expr TK_GE expr
    {
      realpaver::Term lhs(realpaver::Term::SharedRep($1));
      realpaver::Term rhs(realpaver::Term::SharedRep($3));

      realpaver::Constraint c(lhs >= rhs);
      realpaver_bison_problem->addCtr(c);
    }
  ;

obj_statement
  : TK_STR_OBJ obj_list
  ;

obj_list
  : obj_def obj_tail
  ;

obj_tail
  :
  | TK_COMMA obj_list
  ;

obj_def
  : TK_MIN expr
    {
      realpaver::Term f(realpaver::Term::SharedRep($2));
      if (f.isConstant())
      {
        realpaver_bison_error("Constant objective function");
        YYABORT;
      }

      realpaver_bison_problem->addObjective(MIN(f));
    }
  | TK_MAX expr
    {
      realpaver::Term f(realpaver::Term::SharedRep($2));
      if (f.isConstant())
      {
        realpaver_bison_error("Constant objective function");
        YYABORT;
      }

      realpaver_bison_problem->addObjective(MAX(f));       
    }
  ;

fun_statement
  : TK_STR_FUN fun_list
  ;

fun_list
  : fun_def fun_tail
  ;

fun_tail
  :
  | TK_COMMA fun_list
  ;

fun_def
  : ident TK_LPAR
    {       
      if (realpaver_bison_symtab->hasSymbol($1))
      {
        std::ostringstream os;
        os << "Symbol [" << $1 << "] already used";
        realpaver_bison_error(os.str().c_str());
        YYABORT;         
      }

      realpaver_fun_symbol = realpaver_bison_symtab->insertFunction($1);
    }
    arg_list TK_RPAR TK_EQ expr
    {
      realpaver::Term t(realpaver::Term::SharedRep($7));
      bool ok = realpaver_fun_symbol->setTerm(t);      
      realpaver_fun_symbol = nullptr;

      if (!ok)
      {
        realpaver_bison_error("Bad variable in a function expression");
        YYABORT;                  
      }
    }
  ;

arg_list
  : arg_def arg_tail
  ;

arg_tail
  :
  | TK_COMMA arg_list
  ;

arg_def
  : ident
    {
      if (realpaver_fun_symbol->hasArgument($1))
      {
        std::ostringstream os;
        os << "Argument [" << $1 << "] already used";
        realpaver_bison_error(os.str().c_str());
        YYABORT;         
      }

      realpaver_fun_symbol->addArgument($1);
    }
  ;

int_statement
  : TK_STR_INT int_list
  ;

int_list
  : int_def int_tail
  ;

int_tail
  :
  | TK_COMMA int_list
  ;

int_def
  : ident
    {
      realpaver::VariableSymbol* vs = realpaver_bison_symtab->findVariable($1);

      if (vs != nullptr)
      {
         vs->getVar().setDiscrete();
      }
      else
      {
        std::ostringstream os;
        os << "Variable [" << $1 << "] not found";
        realpaver_bison_error(os.str().c_str());
        YYABORT;
      }
    }
  ;

const_expr
  : expr
    {
      realpaver::TermRep* t = $1;

      if (t->isConstant()) $$ = $1;
      else
      {
        delete t;
        realpaver_bison_error("Expression not constant");
        YYABORT;
      }
    }
  ;

expr
  : expr TK_PLUS expr
    {
      realpaver::Term lhs(realpaver::Term::SharedRep($1)),
                      rhs(realpaver::Term::SharedRep($3)),
                      res(lhs + rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_MINUS expr
    {
      realpaver::Term lhs(realpaver::Term::SharedRep($1)),
                      rhs(realpaver::Term::SharedRep($3)),
                      res(lhs - rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_MUL expr
    {
      realpaver::Term lhs(realpaver::Term::SharedRep($1)),
                      rhs(realpaver::Term::SharedRep($3)),
                      res(lhs * rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_DIV expr
    {
      realpaver::Term lhs(realpaver::Term::SharedRep($1)),
                      rhs(realpaver::Term::SharedRep($3)),
                      res(lhs / rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_CARET exponent
    {
      realpaver::Term t(realpaver::Term::SharedRep($1)),
                      d(realpaver::Term::SharedRep($3)),
                      res(pow(t, d.evalConst()));
      $$ = res.cloneRoot();
    }
  | TK_POW TK_LPAR expr TK_COMMA exponent TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      d(realpaver::Term::SharedRep($5)),
                      res(pow(t, d.evalConst()));
      $$ = res.cloneRoot();
    }
  | TK_MINUS expr %prec TK_UMINUS
    {
      realpaver::Term t(realpaver::Term::SharedRep($2)),
                      res(-t);
      $$ = res.cloneRoot();
    }
  | TK_PLUS expr %prec TK_UPLUS
    {
       $$ = $2;
    }
  | TK_SQRT TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(sqrt(t));
      $$ = res.cloneRoot();
    }
  | TK_SQR TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(sqr(t));
      $$ = res.cloneRoot();
    }
  | TK_SGN TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(sgn(t));
      $$ = res.cloneRoot();
    }
  | TK_ABS TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(abs(t));
      $$ = res.cloneRoot();
    }
  | TK_PIPE expr TK_PIPE
    {
      realpaver::Term t(realpaver::Term::SharedRep($2)),
                      res(abs(t));
      $$ = res.cloneRoot();
    }
  | TK_LOG TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(log(t));
      $$ = res.cloneRoot();
    }
  | TK_EXP TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(exp(t));
      $$ = res.cloneRoot();
    }
  | TK_COS TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(cos(t));
      $$ = res.cloneRoot();
    }
  | TK_SIN TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(sin(t));
      $$ = res.cloneRoot();
    }
  | TK_TAN TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(realpaver::Term::SharedRep($3)),
                      res(tan(t));
      $$ = res.cloneRoot();
    }
  | TK_MIN TK_LPAR expr TK_COMMA expr TK_RPAR
    {
      realpaver::Term fst(realpaver::Term::SharedRep($3)),
                      snd(realpaver::Term::SharedRep($5)),
                      res(MIN(fst, snd));
      $$ = res.cloneRoot();
    }
  | TK_MAX TK_LPAR expr TK_COMMA expr TK_RPAR
    {
      realpaver::Term fst(realpaver::Term::SharedRep($3)),
                      snd(realpaver::Term::SharedRep($5)),
                      res(MAX(fst, snd));
      $$ = res.cloneRoot();
    }
  | TK_LPAR expr TK_RPAR
  {
    $$ = $2;
  }
  | fun_call
    {
      $$ = $1;
    }
  | ident
    {
      bool found = false;

      // an argument?
      if (realpaver_fun_symbol != nullptr &&
          realpaver_fun_symbol->hasArgument($1))
      {
        realpaver::Variable v = realpaver_fun_symbol->getVar($1);
        $$ = new realpaver::TermVar(v);
        found = true;
      }

      if (!found)
      {
        // a constant?
        realpaver::ConstantSymbol* cs =
          realpaver_bison_symtab->findConstant($1);

        if (cs != nullptr)
        {
           $$ = new realpaver::TermConst(cs->getValue());
           found = true;
        }
     }

      if (!found)
      {
        // a variable?
        realpaver::VariableSymbol* vs =
          realpaver_bison_symtab->findVariable($1);

        if (vs != nullptr)
        {
           $$ = new realpaver::TermVar(vs->getVar());
           found = true;
        }
      }

      if (!found)
      {
        // an alias?
        realpaver::AliasSymbol* as = realpaver_bison_symtab->findAlias($1);

        if (as != nullptr)
        {
           $$ = as->getTerm().cloneRoot();
           found = true;
        }
      }

      // symbol not found
      if (!found)
      {
        std::ostringstream os;
        os << "Identifier [" << $1 << "] not found";
        realpaver_bison_error(os.str().c_str());
        YYABORT;
      }
    }
  | integer
    {
      $$ = $1;
    }
  | real
    {
      $$ = $1;
    }
  | itv
    {
       $$ = $1;
    }
  ;

fun_call
  : ident TK_LPAR
    {
      realpaver::FunctionSymbol* fs =
          realpaver_bison_symtab->findFunction($1);

      if (fs == nullptr)
      {
        std::ostringstream os;
        os << "Function [" << $1 << "] not found";
        realpaver_bison_error(os.str().c_str());
        YYABORT;
      }

      realpaver_bison_symtab->pushFunctionCall(fs);
    }
    expr_list TK_RPAR
    {
       std::pair<bool, realpaver::Term> res =
         realpaver_bison_symtab->processFunCall();

       if (res.first)
       {
         $$ = res.second.cloneRoot();
       }
       else
       {
         realpaver_bison_error("Function call invalid");
         YYABORT;          
       }
    }
  ;

expr_list
  : expr
    {
      realpaver::Term t(realpaver::Term::SharedRep($1));
      realpaver_bison_symtab->addFunctionArgument(t);
    }
    expr_tail
  ;

expr_tail
  :
  | TK_COMMA expr_list
  ;

exponent
  : integer
    {
      $$ = $1;
    }
  | real
    {
      $$ = $1;
    }
  ;

integer
  : TK_INT
    {
      try
      {
        realpaver::Interval x(realpaver_bison_text);
        $$ = new realpaver::TermConst(x);
      }
      catch(realpaver::Exception e)
      {
        realpaver_bison_error("Bad integer value");
        YYABORT;
      }       
    }
  ;

real
  : TK_REAL
    {
      try
      {
        realpaver::Interval x(realpaver_bison_text);
        $$ = new realpaver::TermConst(x);
      }
      catch(realpaver::Exception e)
      {
        realpaver_bison_error("Bad real number");
        YYABORT;
      }       
    }
  ;

itv
  : TK_LSBR const_expr TK_COMMA const_expr TK_RSBR
    {
      realpaver::Term::SharedRep lo($2);
      realpaver::Term::SharedRep up($4);

      realpaver::Interval x = lo->evalConst();
      realpaver::Interval y = up->evalConst();
      realpaver::Interval z(x.left(), y.right());

      if (z.isEmpty())
      {
        realpaver_bison_error("Empty interval");
        YYABORT;
      }

      $$ = new realpaver::TermConst(z);
    }
  ;

domain
  :
    {
      $$ = new realpaver::TermConst(realpaver::Interval::universe());
    }
  | TK_LE const_expr
    {
      realpaver::Term::SharedRep e($2);
      realpaver::Interval up = e->evalConst();
      realpaver::Interval domain = realpaver::Interval::lessThan(up.right());

      $$ = new realpaver::TermConst(domain);
    }
  | TK_GE const_expr
    {
      realpaver::Term::SharedRep e($2);
      realpaver::Interval lo = e->evalConst();
      realpaver::Interval domain = realpaver::Interval::moreThan(lo.left());

      $$ = new realpaver::TermConst(domain);
    }
  | TK_IN itv
    {
      realpaver::Term::SharedRep e($2);
      realpaver::Interval domain = e->evalConst();

      if (domain.isEmpty())
      {
         realpaver_bison_error("Empty domain");
         YYABORT;
      }

      $$ = new realpaver::TermConst(domain);
    }
  ;

ident
 : TK_IDENT
   {
     strcpy($$, realpaver_bison_text);
   }
   ;
%%

int realpaver_bison_error(const char* str)
{
  std::ostringstream os;   
  os << "l" << realpaver_bison_lineno << ": " << str;

  realpaver_parse_error = os.str();

  return 0;
}
