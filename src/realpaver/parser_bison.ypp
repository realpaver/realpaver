%{
#include <cstring>
#include <sstream>
#include <string>
#include "realpaver/Problem.hpp"
#include "realpaver/SymbolTable.hpp"

#undef YYINITDEPTH
#define YYINITDEPTH 5000

extern char* realpaver_bison_text;
extern int realpaver_bison_lineno;
extern std::string realpaver_parse_error;
extern realpaver::Problem* realpaver_bison_problem;
extern realpaver::SymbolTable* realpaver_bison_symtab;

extern int realpaver_bison_lex(void);
int realpaver_bison_error(const char* str);
%}

%define api.prefix {realpaver_bison_}

%code requires
{
#include "realpaver/Constraint.hpp"
#include "realpaver/Exception.hpp"
}

%union
{
  char u_str[256];
  realpaver::TermRep* u_term;
  int u_integer;
}

%type <u_str>     ident
%type <u_term>    expr
%type <u_term>    const_expr
%type <u_term>    integer
%type <u_term>    real
%type <u_term>    exponent
%type <u_term>    itv
%type <u_term>    domain
%type <u_integer> var_type

%token TK_IDENT TK_INT TK_REAL
%token TK_STR_VAR TK_STR_CONST TK_STR_CTR TK_STR_OBJ TK_STR_FUN
%token TK_STR_INT TK_STR_REAL
%token TK_EQ TK_LE TK_GE TK_IN TK_LT TK_GT
%token TK_PLUS TK_MINUS TK_MUL TK_DIV TK_POW TK_SQRT TK_LOG TK_EXP
%token TK_TAN TK_COS TK_SIN
%token TK_LPAR TK_RPAR TK_LSBR TK_RSBR
%token TK_COMMA TK_SCOLON TK_COLON
%token TK_SGN TK_ABS TK_MIN TK_MAX

%left TK_PLUS TK_MINUS
%left TK_MUL TK_DIV
%right TK_UMINUS
%right TK_UPLUS
%right TK_POW

%start model

%%
model
  : 
  | statement TK_SCOLON model
  ;

statement
  : const_statement
  | var_statement
  | ctr_statement
  | obj_statement
  | fun_statement
  ;

const_statement
  : TK_STR_CONST const_list;

const_list
  : const_def const_tail;

const_tail
  :
  | TK_COMMA const_list;

const_def
  : ident TK_EQ const_expr
    {
      std::shared_ptr<realpaver::TermRep> e($3);

      realpaver::Interval x = e->evalConst();
      if (x.isEmpty())
      {
        std::ostringstream os;
        os << "Constant [" << $1 << "] equal to an empty interval";
        realpaver_bison_error(os.str().c_str());
        YYABORT;
      }

      if (realpaver_bison_symtab->hasSymbol($1))
      {
        std::ostringstream os;
        os << "Symbol [" << $1 << "] already used";
        realpaver_bison_error(os.str().c_str());
        YYABORT;         
      }

      realpaver_bison_symtab->insertConstant($1, x);
    }
  ;

var_statement
  : TK_STR_VAR var_list;

var_list
  : var_def var_tail;

var_tail
  :
  | TK_COMMA var_list;

var_def
  : var_type ident domain
    {
      std::shared_ptr<realpaver::TermRep> e($3);
      realpaver::Interval x = e->evalConst();

      if (realpaver_bison_symtab->hasSymbol($2))
      {
        std::ostringstream os;
        os << "Symbol [" << $2 << "] already used";
        realpaver_bison_error(os.str().c_str());
        YYABORT;         
      }

      if ($1 == 0)
      {
        realpaver::Variable v = realpaver_bison_problem->addIntVar(x, $2);
        realpaver_bison_symtab->insertVariable($2, v);
      }
      else
      {
        realpaver::Variable v = realpaver_bison_problem->addRealVar(x, $2);
        realpaver_bison_symtab->insertVariable($2, v);
      }
    }
  ;

var_type
  :
    {
       $$ = 1;
    }
  | TK_STR_INT
    {
       $$ = 0;       
    }
  | TK_STR_REAL
    {
       $$ = 1;
    }
  ;

ctr_statement
  : TK_STR_CTR ctr_list;

ctr_list
  : ctr_def ctr_tail;

ctr_tail
  :
  | TK_COMMA ctr_list;

ctr_def
  : expr TK_EQ expr
    {
      realpaver::Term lhs(std::shared_ptr<realpaver::TermRep>($1));
      realpaver::Term rhs(std::shared_ptr<realpaver::TermRep>($3));

      realpaver::Constraint c(lhs == rhs);
      realpaver_bison_problem->addCtr(c);
    }
  | expr TK_LE expr
    {
      realpaver::Term lhs(std::shared_ptr<realpaver::TermRep>($1));
      realpaver::Term rhs(std::shared_ptr<realpaver::TermRep>($3));

      realpaver::Constraint c(lhs <= rhs);
      realpaver_bison_problem->addCtr(c);
    }
  | expr TK_GE expr
    {
      realpaver::Term lhs(std::shared_ptr<realpaver::TermRep>($1));
      realpaver::Term rhs(std::shared_ptr<realpaver::TermRep>($3));

      realpaver::Constraint c(lhs >= rhs);
      realpaver_bison_problem->addCtr(c);
    }
  ;

obj_statement
  : TK_STR_OBJ obj_list;

obj_list
  : obj_def obj_tail;

obj_tail
  :
  | TK_COMMA obj_list;

obj_def
  : TK_MIN expr
    {
      realpaver::Term f(std::shared_ptr<realpaver::TermRep>($2));
      if (f.isConstant())
      {
        realpaver_bison_error("Constant objective function");
        YYABORT;
      }

      realpaver_bison_problem->addObjective(MIN(f));
    }
  | TK_MAX expr
    {
      realpaver::Term f(std::shared_ptr<realpaver::TermRep>($2));
      if (f.isConstant())
      {
        realpaver_bison_error("Constant objective function");
        YYABORT;
      }

      realpaver_bison_problem->addObjective(MAX(f));       
    }
  ;

fun_statement
  : TK_STR_FUN fun_list;

fun_list
  : fun_def fun_tail;

fun_tail
  :
  | TK_COMMA fun_list;

fun_def
  : expr
    {
      // TODO
    }
  ;

const_expr
  : expr
    {
      realpaver::TermRep* t = $1;

      if (t->isConstant()) $$ = $1;
      else
      {
        delete t;
        realpaver_bison_error("Expression not constant");
        YYABORT;
      }
    }
  ;

expr
  : expr TK_PLUS expr
    {
      realpaver::Term lhs(std::shared_ptr<realpaver::TermRep>($1)),
                      rhs(std::shared_ptr<realpaver::TermRep>($3)),
                      res(lhs + rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_MINUS expr
    {
      realpaver::Term lhs(std::shared_ptr<realpaver::TermRep>($1)),
                      rhs(std::shared_ptr<realpaver::TermRep>($3)),
                      res(lhs - rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_MUL expr
    {
      realpaver::Term lhs(std::shared_ptr<realpaver::TermRep>($1)),
                      rhs(std::shared_ptr<realpaver::TermRep>($3)),
                      res(lhs * rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_DIV expr
    {
      realpaver::Term lhs(std::shared_ptr<realpaver::TermRep>($1)),
                      rhs(std::shared_ptr<realpaver::TermRep>($3)),
                      res(lhs / rhs);
      $$ = res.cloneRoot();
    }
  | expr TK_POW exponent
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($1)),
                      d(std::shared_ptr<realpaver::TermRep>($3)),
                      res(pow(t, d.evalConst()));
      $$ = res.cloneRoot();
    }
  | TK_MINUS expr %prec TK_UMINUS
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($2)),
                      res(-t);
      $$ = res.cloneRoot();
    }
  | TK_PLUS expr %prec TK_UPLUS
    {
       $$ = $2;
    }
  | TK_SQRT TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(sqrt(t));
      $$ = res.cloneRoot();
    }
  | TK_SGN TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(sgn(t));
      $$ = res.cloneRoot();
    }
  | TK_ABS TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(abs(t));
      $$ = res.cloneRoot();
    }
  | TK_LOG TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(log(t));
      $$ = res.cloneRoot();
    }
  | TK_EXP TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(exp(t));
      $$ = res.cloneRoot();
    }
  | TK_COS TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(cos(t));
      $$ = res.cloneRoot();
    }
  | TK_SIN TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(sin(t));
      $$ = res.cloneRoot();
    }
  | TK_TAN TK_LPAR expr TK_RPAR
    {
      realpaver::Term t(std::shared_ptr<realpaver::TermRep>($3)),
                      res(tan(t));
      $$ = res.cloneRoot();
    }
  | TK_MIN TK_LPAR expr TK_COMMA expr TK_RPAR
    {
      realpaver::Term fst(std::shared_ptr<realpaver::TermRep>($3)),
                      snd(std::shared_ptr<realpaver::TermRep>($5)),
                      res(MIN(fst, snd));
      $$ = res.cloneRoot();
    }
  | TK_MAX TK_LPAR expr TK_COMMA expr TK_RPAR
    {
      realpaver::Term fst(std::shared_ptr<realpaver::TermRep>($3)),
                      snd(std::shared_ptr<realpaver::TermRep>($5)),
                      res(MAX(fst, snd));
      $$ = res.cloneRoot();
    }
  | TK_LPAR expr TK_RPAR
    {
      $$ = $2;
    }
  | ident
    {
      bool found = false;

      // Constant ?
      realpaver::ConstantSymbol* cs =
        realpaver_bison_symtab->findConstant(realpaver_bison_text);

      if (cs != nullptr)
      {
         $$ = new realpaver::TermConst(cs->getValue());
         found = true;
      }

      // Variable ?
      realpaver::VariableSymbol* vs =
        realpaver_bison_symtab->findVariable(realpaver_bison_text);

      if (vs != nullptr)
      {
         $$ = new realpaver::TermVar(vs->getVar());
         found = true;
      }

      // symbol not found
      if (!found)
      {
        std::ostringstream os;
        os << "Identifier [" << realpaver_bison_text << "] not found";
        realpaver_bison_error(os.str().c_str());
        YYABORT;
      }
    }
  | integer
    {
      $$ = $1;
    }
  | real
    {
      $$ = $1;
    }
  ;

exponent
  : integer
    {
      $$ = $1;
    }
  | real
    {
      $$ = $1;
    }
  ;

integer
  : TK_INT
    {
      try
      {
        realpaver::Interval x(realpaver_bison_text);
        $$ = new realpaver::TermConst(x);
      }
      catch(realpaver::Exception e)
      {
        realpaver_bison_error("Bad integer value");
        YYABORT;
      }       
    }
  ;

real
  : TK_REAL
    {
      try
      {
        realpaver::Interval x(realpaver_bison_text);
        $$ = new realpaver::TermConst(x);
      }
      catch(realpaver::Exception e)
      {
        realpaver_bison_error("Bad real number");
        YYABORT;
      }       
    }
  ;

itv
  : TK_LSBR const_expr TK_COMMA const_expr TK_RSBR
    {
      std::shared_ptr<realpaver::TermRep> lo($2);
      std::shared_ptr<realpaver::TermRep> up($4);

      realpaver::Interval x = lo->evalConst();
      realpaver::Interval y = up->evalConst();
      realpaver::Interval z(x.left(), y.right());

      if (z.isEmpty())
      {
        realpaver_bison_error("Empty interval");
        YYABORT;
      }

      $$ = new realpaver::TermConst(z);
    }
  ;

domain
  :
    {
      $$ = new realpaver::TermConst(realpaver::Interval::universe());
    }
  | TK_LE const_expr
    {
      std::shared_ptr<realpaver::TermRep> e($2);
      realpaver::Interval up = e->evalConst();
      realpaver::Interval domain = realpaver::Interval::lessThan(up.right());

      $$ = new realpaver::TermConst(domain);
    }
  | TK_GE const_expr
    {
      std::shared_ptr<realpaver::TermRep> e($2);
      realpaver::Interval lo = e->evalConst();
      realpaver::Interval domain = realpaver::Interval::moreThan(lo.left());

      $$ = new realpaver::TermConst(domain);
    }
  | TK_IN itv
    {
      std::shared_ptr<realpaver::TermRep> e($2);
      realpaver::Interval domain = e->evalConst();

      if (domain.isEmpty())
      {
         realpaver_bison_error("Empty domain");
         YYABORT;
      }

      $$ = new realpaver::TermConst(domain);
    }
  ;

ident
 : TK_IDENT
   {
     strcpy($$, realpaver_bison_text);
   }
   ;
%%

int realpaver_bison_error(const char* str)
{
  std::ostringstream os;   
  os << "l" << realpaver_bison_lineno << ": " << str;

  realpaver_parse_error = os.str();

  return 0;
}
