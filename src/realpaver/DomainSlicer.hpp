/*------------------------------------------------------------------------------
 * Realpaver -- Realpaver is a rigorous nonlinear constraint solver based on
 *              interval computations.
 *------------------------------------------------------------------------------
 * Copyright (c) 2004-2016 Laboratoire d'Informatique de Nantes Atlantique,
 *               France
 * Copyright (c) 2017-2024 Laboratoire des Sciences du Num√©rique de Nantes,
 *               France
 *------------------------------------------------------------------------------
 * Realpaver is a software distributed WITHOUT ANY WARRANTY. Read the COPYING
 * file for information.
 *----------------------------------------------------------------------------*/

/**
 * @file   DomainSlicer.hpp
 * @brief  Classes of domain slicers
 * @author Laurent Granvilliers
 * @date   2024-4-11
*/

#ifndef REALPAVER_DOMAIN_SLICER_HPP
#define REALPAVER_DOMAIN_SLICER_HPP

#include <list>
#include "realpaver/Domain.hpp"

namespace realpaver {

/**
 * @brief Base class of domain slicers.
 *
 * A slicer generates a list of sub-domains, i.e. the slices. The slices are
 * stored in this and they can be accessed through iterators.
*/
class DomainSlicer {
public:
   /// Default constructor
   DomainSlicer() = default;

   /// Destructor
   virtual ~DomainSlicer();

   /// No copy
   DomainSlicer(const DomainSlicer&) = delete;

   /// No assignment
   DomainSlicer& operator=(const DomainSlicer&) = delete;

   /// Slices a domain and returns the number of slices
   size_t apply(Domain* dom);

   /// Returns the number of slices generated by apply(x)
   size_t nbSlices() const;

   /// Clears the container and delete the domains
   void clear();

protected:
   /// Implements the slicing method
   virtual void applyImpl(Domain* dom) = 0;

   /// Inserts a domain in the container
   void push(Domain* dom);

private:
   typedef std::list< std::unique_ptr<Domain> > ContainerType;
   ContainerType cont_;

public:
   /// Iterators on the list of slices
   typedef typename ContainerType::iterator iterator;

   /// Returns an iterator on the beginning of the container of slices
   iterator begin();

   /// Returns an iterator on the end of the container of slices
   iterator end();

   /// Gets a domain and moves the iterator to the next element
   std::unique_ptr<Domain> next(iterator& it);
};

/*----------------------------------------------------------------------------*/

/// Slicer of binary domains
class BinaryDomainSlicer : public DomainSlicer {
public:
   /// Default constructor
   BinaryDomainSlicer() = default;

   /// No copy
   BinaryDomainSlicer(const BinaryDomainSlicer&) = delete;

   /// No assignment
   BinaryDomainSlicer& operator=(const BinaryDomainSlicer&) = delete;

   /// Default destructor
   ~BinaryDomainSlicer() = default;

   void applyImpl(Domain* dom) override;
};

/*----------------------------------------------------------------------------*/

/// Slicer that bisects an interval domain
class IntervalDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   IntervalDomainBisecter() = default;

   /// No copy
   IntervalDomainBisecter(const IntervalDomainBisecter&) = delete;

   /// No assignment
   IntervalDomainBisecter& operator=(const IntervalDomainBisecter&) = delete;

   /// Default destructor
   ~IntervalDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

/*----------------------------------------------------------------------------*/

/**
 * @brief Slicer that divides an interval union domain.
 * 
 * If the union is reduced to one interval, then it is bisected. Otherwise the
 * list of elements of the union is split in two equal parts.
 */
class IntervalUnionDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   IntervalUnionDomainBisecter() = default;

   /// Default copy constructor
   IntervalUnionDomainBisecter(const IntervalUnionDomainBisecter&) = delete;

   /// No assignment
   IntervalUnionDomainBisecter&
      operator=(const IntervalUnionDomainBisecter&) = delete;

   /// Default destructor
   ~IntervalUnionDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

/*----------------------------------------------------------------------------*/

/// Slicer that bisects a range domain
class RangeDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   RangeDomainBisecter() = default;

   /// Default copy constructor
   RangeDomainBisecter(const RangeDomainBisecter&) = delete;

   /// No assignment
   RangeDomainBisecter& operator=(const RangeDomainBisecter&) = delete;

   /// Default destructor
   ~RangeDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

/*----------------------------------------------------------------------------*/

/**
 * @brief Slicer that divides a range union domain.
 * 
 * If this is reduced to one range, then it is bisected. Otherwise the list
 * of elements of the union is split in two equal parts.
 */
class RangeUnionDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   RangeUnionDomainBisecter() = default;

   /// No copy
   RangeUnionDomainBisecter(RangeUnionDomainBisecter&) = delete;

   /// No assignment
   RangeUnionDomainBisecter& operator=(RangeUnionDomainBisecter&) = delete;

   /// Default destructor
   ~RangeUnionDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

} // namespace

#endif
