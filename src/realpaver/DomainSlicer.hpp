///////////////////////////////////////////////////////////////////////////////
// This file is part of Realpaver, an interval constraint and NLP solver.    //
//                                                                           //
// Copyright (c) 2017-2023 LS2N, Nantes                                      //
//                                                                           //
// Realpaver is a software distributed WITHOUT ANY WARRANTY; read the file   //
// COPYING for information.                                                  //
///////////////////////////////////////////////////////////////////////////////

#ifndef REALPAVER_DOMAIN_SLICER_HPP
#define REALPAVER_DOMAIN_SLICER_HPP

#include <list>
#include "realpaver/Domain.hpp"

namespace realpaver {

///////////////////////////////////////////////////////////////////////////////
/// This is a base class of domain slicers.
///
/// A slicer generates a list of sub-domains, i.e. the slices. The slices can be
/// accessed through iterators.
///////////////////////////////////////////////////////////////////////////////
class DomainSlicer {
public:
   /// Default constructor
   DomainSlicer() = default;

   /// Destructor
   virtual ~DomainSlicer();

   /// No copy
   DomainSlicer(const DomainSlicer&) = delete;

   /// No assignment
   DomainSlicer& operator=(const DomainSlicer&) = delete;

   /// Slices a domain
   /// @param x an interval
   /// @return the number of slices
   ///
   /// This method clears the container and calls applyImpl(x).
   size_t apply(Domain* dom);

   /// @return the number of slices generated by apply(x)
   size_t nbSlices() const;

   /// Clears the container and delete the domains
   void clear();

protected:
   /// Implements the slicing method
   virtual void applyImpl(Domain* dom) = 0;

   /// Inserts a domain in the container
   void push(Domain* dom);

private:
   typedef std::list<Domain*> ContainerType;
   ContainerType cont_;

public:
   /// Iterators on the list of slices
   typedef typename ContainerType::iterator iterator;

   /// @returns an iterator on the beginning of the container of slices
   iterator begin();

   /// @returns an iterator on the end of the container of slices
   iterator end();

   /// Gets a domain and moves the iterator to the next element
   /// @param it an iterator on this different from end()
   /// @return the domain pointed by it
   ///
   /// Iterator it is moved to the next element.
   Domain* next(iterator& it);
};

///////////////////////////////////////////////////////////////////////////////
/// This is a slicer of binary domains.
///////////////////////////////////////////////////////////////////////////////
class BinaryDomainSlicer : public DomainSlicer {
public:
   /// Default constructor
   BinaryDomainSlicer() = default;

   /// No copy
   BinaryDomainSlicer(const BinaryDomainSlicer&) = delete;

   /// No assignment
   BinaryDomainSlicer& operator=(const BinaryDomainSlicer&) = delete;

   /// Default destructor
   ~BinaryDomainSlicer() = default;

   void applyImpl(Domain* dom) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This is a slicer that bisects an interval domain.
///////////////////////////////////////////////////////////////////////////////
class IntervalDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   IntervalDomainBisecter() = default;

   /// No copy
   IntervalDomainBisecter(const IntervalDomainBisecter&) = delete;

   /// No assignment
   IntervalDomainBisecter& operator=(const IntervalDomainBisecter&) = delete;

   /// Default destructor
   ~IntervalDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This is a slicer that divides an interval union domain as follows.
/// If it is reduced to one interval, then it is bisected. Otherwise the list
/// of elements of the union is split in two equal parts.
///////////////////////////////////////////////////////////////////////////////
class IntervalUnionDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   IntervalUnionDomainBisecter() = default;

   /// Default copy constructor
   IntervalUnionDomainBisecter(const IntervalUnionDomainBisecter&) = delete;

   /// No assignment
   IntervalUnionDomainBisecter&
      operator=(const IntervalUnionDomainBisecter&) = delete;

   /// Default destructor
   ~IntervalUnionDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This is a slicer that bisects a range domain.
///////////////////////////////////////////////////////////////////////////////
class RangeDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   RangeDomainBisecter() = default;

   /// Default copy constructor
   RangeDomainBisecter(const RangeDomainBisecter&) = delete;

   /// No assignment
   RangeDomainBisecter& operator=(const RangeDomainBisecter&) = delete;

   /// Default destructor
   ~RangeDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

///////////////////////////////////////////////////////////////////////////////
/// This is a slicer that divides a range union domain as follows.
/// If it is reduced to one range, then it is bisected. Otherwise the list
/// of elements of the union is split in two equal parts.
///////////////////////////////////////////////////////////////////////////////
class RangeUnionDomainBisecter : public DomainSlicer {
public:
   /// Default constructor
   RangeUnionDomainBisecter() = default;

   /// No copy
   RangeUnionDomainBisecter(RangeUnionDomainBisecter&) = delete;

   /// No assignment
   RangeUnionDomainBisecter& operator=(RangeUnionDomainBisecter&) = delete;

   /// Default destructor
   ~RangeUnionDomainBisecter() = default;

   void applyImpl(Domain* dom) override;
};

} // namespace

#endif
