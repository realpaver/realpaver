# How to solve a constraint satisfaction problem

## Using the command-line

When building the RealPaver library, a default CSP solver is also generated, namely `csp_solver`. It is able to solve CSPs written using the [RealPaver dedicated language](language.md).

From the command line, the solver requires the file path to the problem desciption written in the RealPaver language. Thus, solving a CSP relating to a 2R planar robot, described in the file '2r-robot.rp', can be solved as follows:

``` bash
# Run with default parameters
csp_solver 2r-robot.rp
```

[RealPaver parameters](parameters.md) can be specified with prefix `-p` in a dedicated text file to adapt the behavior of the solver. For instance, the solver can be called to solve again the 2R planar robot problem with some parameters overloaded by the definitions in 'param.txt', as follows:

``` bash
# Run with specific parameters in param.txt
csp_solver -p param.txt 2r-robot.rp
```

The following problem file describes a 2R planar robot.

``` py
# 2R planar robot with 2 revolute joints
Constants
   l1 = 4.5,               # length of link 1
   l2 = 3.0;               # length of link 2

Variables
   q1 in [-PI, +PI],       # angle of link 1
   q2 in [-PI, +PI],       # angle of link 2
   x in [-10, 10],         # abcissa of end effector
   y in [-10, 10];         # ordinate of end effector

Constraints
   # general
   x == l1*cos(q1) + l2*cos(q1+q2),
   y == l1*sin(q1) + l2*sin(q1+q2),

   # inverse kinematics
   x == 5.75, y == 4.25;
```

The following parameter file overloads the default values for the corresponding parameters:

``` bash
# in seconds
TIME_LIMIT=1000

# Postprocessing
CERTIFICATION=YES

# Display traces in terminal
TRACE=YES

# Absolute tolerance on the width of intervals
VAR_ABS_TOL=1e-10

# Limit on the depth of nodes of search tree
DEPTH_LIMIT=1000

# Limit on the number of nodes generated by the solving algorithm
NODE_LIMIT=1000000
```

## Using the C++ API

It is necessary to include the main header of the API and to use the namespace.

``` cpp
#include "realpaver_api.hpp"
using namespace realpaver;
```

Then, before calling the solver, the problem has to be defined and there are 2 possibilities: using the RealPaver modeling language or using the C++ API.

### Describing the problem with the RealPaver language

The 2R planar robot described above can be processed by a C++ program.

A try/catch block (e.g. in a main function) contains the application code.

``` cpp
try {
   // application (code given below)
}
catch(Exception e) {
   cout << e.what() << endl;
}
```

Parameters are loaded from the given file.

``` cpp
Param prm;                      // Default parameters
prm.loadParam("param.txt");     // Overloading some parameters
```

An empty problem instance is created:

``` cpp
Problem problem;
```

Then, the problem is populated using `2r-robot.rp` file using the parser:

``` cpp
Parser parser(prm);     // Configuring the parser with parameters
bool ok = parser.parseFile("2r-robot.rp", problem);
```

The solver is created for the problem. The parameters are applied to the solver inner context, i.e. its environment, and finally it is called to solve the problem:

``` cpp
CspSolver solver(problem);
solver.getEnv()->setParam(prm);
solver.solve();
```

The solutions can be printed one by one:

``` cpp
for (size_t i=0; i<solver.nbSolutions(); ++i)
{
   pair<DomainBox, Proof> sol = solver.getSolution(i);
   cout << "SOL " << i << ": " << sol.first
        << " (" << sol.second << ")" << endl;
}
```

Additional information on the solving process can also be printed:

``` c++
cout << solver.nbSolutions() <<" solutions found in "
     << solver.getSolvingTime() <<" s, using "
     << solver.getTotalNodes() << " nodes." << endl;
```

### Describing the problem in C++

It is also possible to define the problem without calling the parser. Then, variables and constraints have to be defined in C++, like below:

``` cpp
// Variables
double l1 = 4.5, l2 = 3.0;
Variable q1 = problem.addRealVar(Interval::minusPiPlusPi(), "q1"),
         q2 = problem.addRealVar(Interval::minusPiPlusPi(), "q2"),
         x = problem.addRealVar(-10, 10, "x"),
         y = problem.addRealVar(-10, 10, "y");

// Constraints
problem.addCtr({ x == l1*cos(q1) + l2*cos(q1+q2),
                 y == l1*sin(q1) + l2*sin(q1+q2),
                 x == 5.75,
                 y == 4.25});
```

## A complete example file

``` c++
#include <iostream>
using namespace std;

#include "realpaver_api.hpp"
using namespace realpaver;

int main()
{
    try {
        Param prm;
        prm.loadParam("../../examples/param.txt");

        Problem problem;

        /**** Variables and constraints to be replaced by the code using the parser ****/
        // Variables
        double l1 = 4.5, l2 = 3.0;
        Variable q1 = problem.addRealVar(Interval::minusPiPlusPi(), "q1"),
                 q2 = problem.addRealVar(Interval::minusPiPlusPi(), "q2"),
                 x = problem.addRealVar(-10, 10, "x"),
                 y = problem.addRealVar(-10, 10, "y");

        // Constraints
        problem.addCtr({ x == l1*cos(q1) + l2*cos(q1+q2),
                         y == l1*sin(q1) + l2*sin(q1+q2),
                         x == 5.75,
                         y == 4.25});

        CspSolver solver(problem);
        solver.getEnv()->setParam(prm);
        solver.solve();
        for (size_t i=0; i<solver.nbSolutions(); ++i)
        {
            pair<DomainBox, Proof> sol = solver.getSolution(i);
            cout << "SOL " << i << ": " << sol.first
                 << " (" << sol.second << ")" << endl;
        }
        cout << solver.nbSolutions() <<" solutions found in "
             << solver.getSolvingTime() <<" s, using "
             << solver.getTotalNodes() << " nodes." << endl;
    }
    catch(Exception e) {
       cout << e.what() << endl;
    }

    return 0;
}
```
